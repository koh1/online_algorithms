
2.4.2 ページングにおける乱択アルゴリズム
---------------------------------------------------------------------

概要
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* Pagingに関して基本フェーズの概念を導入し、そこで起こるmiss hit数/miss hit数の期待値を考える

  * Cacheサイズを :math:`k` とする
  * 基本フェーズ :math:`L_i` 
    
    * ページングの開始から数えて、要求されるページの種類が :math:`k` 種類となる最大区間を :math:`L_1 = [\sigma_1, \sigma_2, \ldots, \sigma_{t(1)}]` とする
    * :math:`L_i` は :math:`L_{i-1}` 終了後から数えて、:math:`k` 種類のページ要求がある最大区間である


.. list-table::
   :widths: 1 2
   :header-rows: 1           

   * - Paging Algorithms
     - Description
   * - FIFO (Firt-In-First-Out)
     - キュー
   * - LIFO (Last-In-First-Out)
     - スタック
   * - LRU (Least-Recently-Used)
     -
   * - FC (Frequency-Count)
     - 
   * - Clear
     - 

.. list-table::
   :widths: 1 2 2
   :header-rows: 1
   :stub-columns: 1

   * - \
     - Adaptive Adversary
     - Oblivious Adversary
   * - \
     - 評価対象のオンラインアルゴリズムのプログラムコード、および実行時の挙動を知った上で、実行結果に従って、同アルゴリズムへの入力列を生成する
     - 評価対象のオンラインアルゴリズムのプログラムコードのみを知り、入力列をあらかじめ作る。**オンラインアルゴリズムのプログラムコードに乱択性が無ければ、AdaptiveとObliviousで差は無い** 
   * - ON-line Optimized Algorithm
     - *Adaptive Adversary + On-line*
       [ *最適でない何者か(on line)と比較しても仕方がないからか、本書では登場しない*]
     - *Oblivious Adversary + On-line* 
       [ *下記と一致の理由は?* ]
   * - OFF-line Optimized Algorithm
     - *Adaptive Adversary + Off-line*
       [ *これまでの評価* ]
     - *Oblivious Adversary + Off-line*
       [ **ここでの評価** ]



マーキングアルゴリズムとその乱択化
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* マーキングアルゴリズム
 
  * 手順

    #. ページがリクエストされたとき、そのページにマークをつける。
    #. 高速記憶装置がいっぱいになり、ページフォルトによる消去が必要になったとき、マークが付いてないページがあれば、マークのないページを1つ（もしくは複数）選び消去する。
    #. すべてのページにマークがついていれば、すべてのマークを解除して、どれかのページを消去する。

  * 特徴

    * 挙動は「LRU(Least-Recently-Used): 最近のページ要求が最も古いデータを削除する」と一致する

* 乱択マーキングアルゴリズム **MARK**
  
  * マーキングアルゴリズムのうち特に「マークの無いページから、ランダムに一つ選び消去する」という戦略を持つマーキングアルゴリズムを **Random Select Marking Algorithm: MARK** と呼ぶ。


**演習問題 2.9**

..

  LRU, Clearはマーキングアルゴリズムとして記述できることを示せ

マーキングアルゴリズムの手順を制約としてそれに処理を付加することで実現できることを示してみる。マークの無いページから、削除対象としてどれを選ぶかがそれぞれのアルゴリズムの特徴となる(?)

* LRU

  #. ページがリクエストされたとき、そのページにマークをつける。 *加えて同ページの最終アクセス時刻を記録する*
  #. 高速記憶装置がいっぱいになったら、

     #. すべてのページにマークが付いていれば、すべてのマークを解除
     #. マークのないページを1つ（もしくは複数）選び消去する。

        * その際、**ページの最終アクセス時刻を確認し、その値が最も古いもの(すべて/の位置Xにあるもの)を削除する** 


* Clear

  #. ページがリクエストされたとき、そのページにマークをつける。 *加えて同ページの最終アクセス時刻を記録する*
  #. 高速記憶装置がいっぱいになったら、

     #. すべてのページにマークが付いていれば、すべてのマークを解除
     #. マークのないページを1つ（もしくは複数）選び消去する。

        * その際、**XXX**

..
  
  どのようなマーキングアルゴリズムも競合比が :math:`k` 以下であることを示せ

*定理2.6に示されている通り。* 

マーキングであろうが何であろうが、Cache size= :math:`k` のページングの基本フェーズ :math:`L_i=[\sigma_{t(i-1)+1}, \sigma_{t(i-1)+2}, \ldots \sigma_{t(i)}]` において、ページングアルゴリズムに毎回faultを起こさせるようなページ要求列を作れば、そのfault回数は :math:`k` 回である。一方でOFF lineでは将来にわたっての要求がわかるため、フェーズ移行時の1回のみ。ゆえに競合比= :math:`k` 

..

  FIFOはマーキングアルゴリズムではないことを示せ

マーキングされていないPageも削除対象となるから?


MARKの競合比
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* LRUは競合比 :math:`k` 。これはAdversaryが毎回miss hitを起こすような最悪の入力を作れるためである
* MARKに変更すると、乱択要素が入るので Adversaryは毎回miss hitを起こすような最悪の入力を **作れなくなる**
* その場合の競合比は :math:`2H_k - 1 \leq \bar{R}_{\rm OBL}({\rm MARK}) \leq 2H_k` となる


* memo

  * LRUの定義ではLRUなPageのどれか一つを選んで消去する、としか書いておらず、それは乱択の要素が入っているように見えるにも関わらず、競合比がkであるところに違和感があった。

    * 前節は、LRUアルゴリズムに対してadversaryが毎回faultを起こせる入力列を作れた場合、の話をしている

      * すなわち、LRUなPageのどれか一つを選んで、ではなくLRUなPageのうち1番目とか固定的に決めているものを前節ではLRUアルゴリズムと呼んでいた、ということ

    * 乱択要素により、faultが毎回おこるわけではなくなる。そこを起こる確率(miss hit数の期待値)で議論しているのがここ

**定理 2.11**

..

  アルゴリズムMARKの競合比の期待値 :math:`\bar{R}_{\rm OBL}({\rm MARK})` は :math:`2H_k` 以下である。

**定理 2.12**

..

  :math:`\bar{R}_{\rm OBL} ({\rm MARK})` は :math:`2H_k - 1` 以上である


**定理 2.13 (ページングに対する乱択アルゴリズムの下界定理)**

..

  どんな乱択アルゴリズムALGに対しても :math:`\bar{R}_{\rm OBL} ({\rm ALG}) > 2H_k` である


